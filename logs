commit 80b377150dbf49078141fc82fd60a3861251c908
Author: tczarnia <tristanczk@yahoo.fr>
Date:   Thu Jun 29 09:25:07 2023 +0200

    handled empty server block and empty location block as error

diff --git a/includes/Location.hpp b/includes/Location.hpp
index ea0a6a3..60f84e6 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -42,11 +42,14 @@ public:
 
 	bool parseLocationContent(std::istream& config) {
 		std::string line, keyword, val;
+		bool empty = true;
 		for (; std::getline(config, line);) {
 			std::istringstream iss(line);
 			if (!(iss >> keyword))
 				continue;
 			if (keyword == "}") {
+				if (empty)
+					return configFileError("empty location block");
 				checkIndexPages();
 				checkErrorPages();
 				checkReturn();

commit e1ba77bfd1637dca6cf8e7cdc1515a7de64247d1
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 29 05:47:52 2023 +0200

    remove overkill defines

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 89491ae..ea0a6a3 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -90,8 +90,7 @@ private:
 	std::string _cgiExec;
 	bool _autoIndex;
 	std::pair<long, std::string> _return;
-	bool _allowedMethods[NO_METHOD]; // NO_METHOD is equivalent to the number of methods in the
-									 // RequestMethod enum
+	bool _allowedMethods[NO_METHOD];
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
 	const std::map<int, std::string>& _serverErrorPages;
@@ -121,12 +120,10 @@ private:
 		if (!(iss >> method))
 			return configFileError("missing information after limit_except keyword");
 		std::fill_n(_allowedMethods, NO_METHOD, false);
-		if (!updateMethod(method))
-			return false;
-		while (iss >> method) {
+		do {
 			if (!updateMethod(method))
 				return false;
-		}
+		} while (iss >> method);
 		return true;
 	}
 

commit f4ca46ba87a8d9cef42a3b8d3af606c94ed299ae
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 29 05:37:01 2023 +0200

    PascalCase enums and structs

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 82b6a94..89491ae 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -83,8 +83,8 @@ public:
 
 private:
 	typedef bool (Location::*KeywordHandler)(std::istringstream&);
-	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;
-	t_modifier _modifier;
+	typedef enum Modifier { NONE, REGEX, EXACT } Modifier;
+	Modifier _modifier;
 	std::string _uri;
 	std::string _rootDir;
 	std::string _cgiExec;

commit 1a424314b6df0572a2b5e720e190d948512296a8
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 29 05:33:01 2023 +0200

    bring back print methods

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 890de5a..82b6a94 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -168,4 +168,28 @@ private:
 		if (_return.first == -1 && _serverReturn.first != -1)
 			_return = _serverReturn;
 	}
+
+public:
+	void print() const {
+		std::cout << "Location information:" << std::endl;
+		std::cout << "Modifier: "
+				  << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact"))
+				  << std::endl;
+		std::cout << "URI: " << _uri << std::endl;
+		std::cout << "Root directory: " << _rootDir << std::endl;
+		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
+		std::cout << "Return code: " << _return.first << ", url: " << _return.second << std::endl;
+		std::cout << "Allowed methods: " << (_allowedMethods[GET] ? "GET " : "")
+				  << (_allowedMethods[POST] ? "POST " : "")
+				  << (_allowedMethods[DELETE] ? "DELETE " : "") << std::endl;
+		std::cout << "Error pages:" << std::endl;
+		for (std::map<int, std::string>::const_iterator it = _errorPages.begin();
+			 it != _errorPages.end(); it++)
+			std::cout << "error " << it->first << ": " << it->second << std::endl;
+		std::cout << "Index pages: ";
+		for (std::vector<std::string>::const_iterator it = _indexPages.begin();
+			 it != _indexPages.end(); it++)
+			std::cout << *it << ", ";
+		std::cout << std::endl;
+	}
 };

commit fd95080de20904446fe8818cb067afd02dd893b9
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 29 05:22:07 2023 +0200

    remove print* methods

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 733d460..890de5a 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -79,29 +79,6 @@ public:
 		return LOCATION_MATCH_NONE;
 	}
 
-	void printLocationInformation() const {
-		std::cout << "Location information:" << std::endl;
-		std::cout << "Modifier: "
-				  << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact"))
-				  << std::endl;
-		std::cout << "URI: " << _uri << std::endl;
-		std::cout << "Root directory: " << _rootDir << std::endl;
-		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
-		std::cout << "Return code: " << _return.first << ", url: " << _return.second << std::endl;
-		std::cout << "Allowed methods: " << (_allowedMethods[GET] ? "GET " : "")
-				  << (_allowedMethods[POST] ? "POST " : "")
-				  << (_allowedMethods[DELETE] ? "DELETE " : "") << std::endl;
-		std::cout << "Error pages:" << std::endl;
-		for (std::map<int, std::string>::const_iterator it = _errorPages.begin();
-			 it != _errorPages.end(); it++)
-			std::cout << "error " << it->first << ": " << it->second << std::endl;
-		std::cout << "Index pages: ";
-		for (std::vector<std::string>::const_iterator it = _indexPages.begin();
-			 it != _indexPages.end(); it++)
-			std::cout << *it << ", ";
-		std::cout << std::endl;
-	}
-
 	std::string getCgiExec() const { return _cgiExec; }
 
 private:

commit 6fc30358bd35e51efd112a7e9634506a33841e07
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 29 05:10:58 2023 +0200

    std::fill_n cause im so 1337 uwu

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 10dc01b..733d460 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -12,8 +12,7 @@ public:
 		  _return(-1, ""), _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
 		  _serverReturn(serverReturn) {
 		initKeywordMap();
-		for (int i = 0; i < NO_METHOD; i++)
-			_allowedMethods[i] = true;
+		std::fill_n(_allowedMethods, NO_METHOD, true);
 	}
 
 	~Location(){};
@@ -144,8 +143,7 @@ private:
 		std::string method;
 		if (!(iss >> method))
 			return configFileError("missing information after limit_except keyword");
-		for (int i = 0; i < NO_METHOD; i++)
-			_allowedMethods[i] = false;
+		std::fill_n(_allowedMethods, NO_METHOD, false);
 		if (!updateMethod(method))
 			return false;
 		while (iss >> method) {

commit 58de90edd2ce23eec0703f4ab3568e696ca7a8c5
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Thu Jun 22 10:14:39 2023 +0200

    Request::parse good?

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 13c866a..10dc01b 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -8,8 +8,8 @@ public:
 			 const std::map<int, std::string>& serverErrorPages,
 			 const std::vector<std::string>& serverIndexPages,
 			 const std::pair<long, std::string>& serverReturn)
-		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex), _return(-1, ""),
-		  _cgiExec(""), _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
+		: _modifier(NONE), _uri(""), _rootDir(rootDir), _cgiExec(""), _autoIndex(autoIndex),
+		  _return(-1, ""), _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
 		  _serverReturn(serverReturn) {
 		initKeywordMap();
 		for (int i = 0; i < NO_METHOD; i++)

commit a87cb96dcda9ccbde5ba61345556a5a835f3085b
Author: tczarnia <tristanczk@yahoo.fr>
Date:   Wed Jun 21 16:05:42 2023 +0200

    improved buildCGI function + function to get the valid path to cgi exec

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 32fdf8f..13c866a 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -9,7 +9,7 @@ public:
 			 const std::vector<std::string>& serverIndexPages,
 			 const std::pair<long, std::string>& serverReturn)
 		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex), _return(-1, ""),
-		  _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
+		  _cgiExec(""), _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
 		  _serverReturn(serverReturn) {
 		initKeywordMap();
 		for (int i = 0; i < NO_METHOD; i++)
@@ -103,6 +103,8 @@ public:
 		std::cout << std::endl;
 	}
 
+	std::string getCgiExec() const { return _cgiExec; }
+
 private:
 	typedef bool (Location::*KeywordHandler)(std::istringstream&);
 	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;

commit fe3caf42a4d4fd7f85922629c3e676f0324c8d9c
Author: tczarnia <tristanczk@yahoo.fr>
Date:   Wed Jun 21 14:49:14 2023 +0200

    added cgi parsing in location

diff --git a/includes/Location.hpp b/includes/Location.hpp
index d74a787..32fdf8f 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -109,6 +109,7 @@ private:
 	t_modifier _modifier;
 	std::string _uri;
 	std::string _rootDir;
+	std::string _cgiExec;
 	bool _autoIndex;
 	std::pair<long, std::string> _return;
 	bool _allowedMethods[NO_METHOD]; // NO_METHOD is equivalent to the number of methods in the
@@ -127,13 +128,15 @@ private:
 		_keywordHandlers["index"] = &Location::parseIndex;
 		_keywordHandlers["return"] = &Location::parseReturn;
 		_keywordHandlers["limit_except"] = &Location::parseMethods;
+		_keywordHandlers["cgi"] = &Location::parseCgi;
 	}
 
-	bool parseRoot(std::istringstream& iss) { return ::parseRoot(iss, _rootDir); }
+	bool parseRoot(std::istringstream& iss) { return ::parseString(iss, _rootDir, "root"); }
 	bool parseAutoIndex(std::istringstream& iss) { return ::parseAutoIndex(iss, _autoIndex); }
 	bool parseErrorPages(std::istringstream& iss) { return ::parseErrorPages(iss, _errorPages); }
 	bool parseIndex(std::istringstream& iss) { return ::parseIndex(iss, _indexPages); }
 	bool parseReturn(std::istringstream& iss) { return ::parseReturn(iss, _return); }
+	bool parseCgi(std::istringstream& iss) { return ::parseString(iss, _cgiExec, "cgi"); }
 
 	bool parseMethods(std::istringstream& iss) {
 		std::string method;

commit 2abf3e480aadacb7b1950ded29419a4dbc3da573
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Wed Jun 21 08:25:39 2023 +0200

    lowercase error messages and 2 new invalid confs

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 773bef6..d74a787 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -32,12 +32,12 @@ public:
 			else if (modifier == "=")
 				_modifier = EXACT;
 			else
-				return configFileError("Invalid modifier for location: " + modifier);
+				return configFileError("invalid modifier for location: " + modifier);
 			if (!(iss >> check))
 				return configFileError(ERROR_LOCATION);
 		}
 		if (iss >> check)
-			return configFileError("Too many arguments for location");
+			return configFileError("too many arguments for location");
 		return true;
 	}
 
@@ -60,11 +60,11 @@ public:
 					if (!(this->*handler)(iss))
 						return false;
 				} catch (const std::exception& e) {
-					return configFileError("Invalid keyword in location block: " + keyword);
+					return configFileError("invalid keyword in location block: " + keyword);
 				}
 			}
 		}
-		return configFileError("Missing closing bracket for location block");
+		return configFileError("missing closing bracket for location block");
 	};
 
 	int isMatching(const std::string& requestPath) const {
@@ -138,7 +138,7 @@ private:
 	bool parseMethods(std::istringstream& iss) {
 		std::string method;
 		if (!(iss >> method))
-			return configFileError("Missing information after limit_except keyword");
+			return configFileError("missing information after limit_except keyword");
 		for (int i = 0; i < NO_METHOD; i++)
 			_allowedMethods[i] = false;
 		if (!updateMethod(method))
@@ -153,18 +153,18 @@ private:
 	bool updateMethod(std::string const& method) {
 		if (method == "GET") {
 			if (_allowedMethods[GET])
-				return configFileError("Multiple GET instructions in limit_except directive");
+				return configFileError("multiple GET instructions in limit_except directive");
 			_allowedMethods[GET] = true;
 		} else if (method == "POST") {
 			if (_allowedMethods[POST])
-				return configFileError("Multiple POST instructions in limit_except directive");
+				return configFileError("multiple POST instructions in limit_except directive");
 			_allowedMethods[POST] = true;
 		} else if (method == "DELETE") {
 			if (_allowedMethods[DELETE])
-				return configFileError("Multiple DELETE instructions in limit_except directive");
+				return configFileError("multiple DELETE instructions in limit_except directive");
 			_allowedMethods[DELETE] = true;
 		} else
-			return configFileError("Invalid method in limit_except directive: " + method);
+			return configFileError("invalid method in limit_except directive: " + method);
 		return true;
 	}
 

commit 7022e125867256d300e601b7f2b47feb67ad01a8
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Tue Jun 20 22:31:12 2023 +0200

    bool configFileError

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 35045c2..773bef6 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -20,12 +20,8 @@ public:
 
 	bool initUri(std::istringstream& iss) {
 		std::string modifier, uri, check;
-		if (!(iss >> modifier >> uri)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {'"
-					  << std::endl;
-			return false;
-		}
+		if (!(iss >> modifier >> uri))
+			return configFileError(ERROR_LOCATION);
 		if (uri == "{") {
 			_uri = modifier;
 			_modifier = NONE;
@@ -35,22 +31,13 @@ public:
 				_modifier = REGEX;
 			else if (modifier == "=")
 				_modifier = EXACT;
-			else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier
-						  << std::endl;
-				return false;
-			}
-			if (!(iss >> check)) {
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {'"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (iss >> check) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments for location" << std::endl;
-			return false;
+			else
+				return configFileError("Invalid modifier for location: " + modifier);
+			if (!(iss >> check))
+				return configFileError(ERROR_LOCATION);
 		}
+		if (iss >> check)
+			return configFileError("Too many arguments for location");
 		return true;
 	}
 
@@ -73,14 +60,11 @@ public:
 					if (!(this->*handler)(iss))
 						return false;
 				} catch (const std::exception& e) {
-					std::cerr << CONFIG_FILE_ERROR
-							  << "Invalid keyword in location block: " << keyword << std::endl;
-					return false;
+					return configFileError("Invalid keyword in location block: " + keyword);
 				}
 			}
 		}
-		std::cerr << CONFIG_FILE_ERROR << "Missing closing bracket for location block" << std::endl;
-		return false;
+		return configFileError("Missing closing bracket for location block");
 	};
 
 	int isMatching(const std::string& requestPath) const {
@@ -153,11 +137,8 @@ private:
 
 	bool parseMethods(std::istringstream& iss) {
 		std::string method;
-		if (!(iss >> method)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after limit_except keyword"
-					  << std::endl;
-			return false;
-		}
+		if (!(iss >> method))
+			return configFileError("Missing information after limit_except keyword");
 		for (int i = 0; i < NO_METHOD; i++)
 			_allowedMethods[i] = false;
 		if (!updateMethod(method))
@@ -171,31 +152,19 @@ private:
 
 	bool updateMethod(std::string const& method) {
 		if (method == "GET") {
-			if (_allowedMethods[GET]) {
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Multiple GET instructions in limit_except directive" << std::endl;
-				return false;
-			}
+			if (_allowedMethods[GET])
+				return configFileError("Multiple GET instructions in limit_except directive");
 			_allowedMethods[GET] = true;
 		} else if (method == "POST") {
-			if (_allowedMethods[POST]) {
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Multiple POST instructions in limit_except directive" << std::endl;
-				return false;
-			}
+			if (_allowedMethods[POST])
+				return configFileError("Multiple POST instructions in limit_except directive");
 			_allowedMethods[POST] = true;
 		} else if (method == "DELETE") {
-			if (_allowedMethods[DELETE]) {
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Multiple DELETE instructions in limit_except directive" << std::endl;
-				return false;
-			}
+			if (_allowedMethods[DELETE])
+				return configFileError("Multiple DELETE instructions in limit_except directive");
 			_allowedMethods[DELETE] = true;
-		} else {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid method in limit_except directive: " << method
-					  << std::endl;
-			return false;
-		}
+		} else
+			return configFileError("Invalid method in limit_except directive: " + method);
 		return true;
 	}
 

commit 5c2d967e7dea3e5329693d81f3a2d06e85f3d126
Author: Axel Brisse <axel.brisse@gmail.com>
Date:   Tue Jun 20 21:42:28 2023 +0200

    push to push

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 4a4e49f..35045c2 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -145,35 +145,11 @@ private:
 		_keywordHandlers["limit_except"] = &Location::parseMethods;
 	}
 
-	bool parseRoot(std::istringstream& iss) {
-		if (!::parseRoot(iss, _rootDir))
-			return false;
-		return true;
-	}
-
-	bool parseAutoIndex(std::istringstream& iss) {
-		if (!::parseAutoIndex(iss, _autoIndex))
-			return false;
-		return true;
-	}
-
-	bool parseErrorPages(std::istringstream& iss) {
-		if (!::parseErrorPages(iss, _errorPages))
-			return false;
-		return true;
-	}
-
-	bool parseIndex(std::istringstream& iss) {
-		if (!::parseIndex(iss, _indexPages))
-			return false;
-		return true;
-	}
-
-	bool parseReturn(std::istringstream& iss) {
-		if (!::parseReturn(iss, _return))
-			return false;
-		return true;
-	}
+	bool parseRoot(std::istringstream& iss) { return ::parseRoot(iss, _rootDir); }
+	bool parseAutoIndex(std::istringstream& iss) { return ::parseAutoIndex(iss, _autoIndex); }
+	bool parseErrorPages(std::istringstream& iss) { return ::parseErrorPages(iss, _errorPages); }
+	bool parseIndex(std::istringstream& iss) { return ::parseIndex(iss, _indexPages); }
+	bool parseReturn(std::istringstream& iss) { return ::parseReturn(iss, _return); }
 
 	bool parseMethods(std::istringstream& iss) {
 		std::string method;

commit 1cfe88f05f8f20eff77548bb14954ddfa7d83301
Author: tczarnia <tristanczk@yahoo.fr>
Date:   Mon Jun 12 16:41:34 2023 +0200

    added function to manage epoll and sockets

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 18f2dcc..4a4e49f 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -4,11 +4,13 @@
 
 class Location {
 public:
-	Location(const std::string& rootDir, bool autoIndex, const std::map<int, std::string>& serverErrorPages,
-			 const std::vector<std::string>& serverIndexPages, const std::pair<long, std::string>& serverReturn)
-		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex),
-		 	_return(-1, ""), _serverErrorPages(serverErrorPages),
-		  _serverIndexPages(serverIndexPages), _serverReturn(serverReturn) {
+	Location(const std::string& rootDir, bool autoIndex,
+			 const std::map<int, std::string>& serverErrorPages,
+			 const std::vector<std::string>& serverIndexPages,
+			 const std::pair<long, std::string>& serverReturn)
+		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex), _return(-1, ""),
+		  _serverErrorPages(serverErrorPages), _serverIndexPages(serverIndexPages),
+		  _serverReturn(serverReturn) {
 		initKeywordMap();
 		for (int i = 0; i < NO_METHOD; i++)
 			_allowedMethods[i] = true;
@@ -125,7 +127,8 @@ private:
 	std::string _rootDir;
 	bool _autoIndex;
 	std::pair<long, std::string> _return;
-	bool _allowedMethods[NO_METHOD]; //NO_METHOD is equivalent to the number of methods in the RequestMethod enum
+	bool _allowedMethods[NO_METHOD]; // NO_METHOD is equivalent to the number of methods in the
+									 // RequestMethod enum
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
 	const std::map<int, std::string>& _serverErrorPages;
@@ -190,36 +193,31 @@ private:
 		return true;
 	}
 
-	bool updateMethod(std::string const & method) {
-		if (method == "GET")
-		{
-			if (_allowedMethods[GET])
-			{
-				std::cerr << CONFIG_FILE_ERROR << "Multiple GET instructions in limit_except directive" << std::endl;
+	bool updateMethod(std::string const& method) {
+		if (method == "GET") {
+			if (_allowedMethods[GET]) {
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Multiple GET instructions in limit_except directive" << std::endl;
 				return false;
 			}
 			_allowedMethods[GET] = true;
-		}
-		else if (method == "POST")
-		{
-			if (_allowedMethods[POST])
-			{
-				std::cerr << CONFIG_FILE_ERROR << "Multiple POST instructions in limit_except directive" << std::endl;
+		} else if (method == "POST") {
+			if (_allowedMethods[POST]) {
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Multiple POST instructions in limit_except directive" << std::endl;
 				return false;
 			}
 			_allowedMethods[POST] = true;
-		}
-		else if (method == "DELETE")
-		{
-			if (_allowedMethods[DELETE])
-			{
-				std::cerr << CONFIG_FILE_ERROR << "Multiple DELETE instructions in limit_except directive" << std::endl;
+		} else if (method == "DELETE") {
+			if (_allowedMethods[DELETE]) {
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Multiple DELETE instructions in limit_except directive" << std::endl;
 				return false;
 			}
 			_allowedMethods[DELETE] = true;
-		}
-		else {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid method in limit_except directive: " << method << std::endl;
+		} else {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid method in limit_except directive: " << method
+					  << std::endl;
 			return false;
 		}
 		return true;

commit 179738df192c4871fc1aa9519e04c0b51c3910c6
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Fri Jun 9 13:30:55 2023 +0200

    modified parsing to avoid long duplicate functions

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 209136d..18f2dcc 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -143,169 +143,32 @@ private:
 	}
 
 	bool parseRoot(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after root keyword" << std::endl;
+		if (!::parseRoot(iss, _rootDir))
 			return false;
-		}
-		_rootDir = value;
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after root keyword" << std::endl;
-			return false;
-		}
 		return true;
 	}
 
 	bool parseAutoIndex(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword"
-					  << std::endl;
-			return false;
-		}
-		if (value == "on")
-			_autoIndex = true;
-		else if (value == "off")
-			_autoIndex = false;
-		else {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value
-					  << std::endl;
+		if (!::parseAutoIndex(iss, _autoIndex))
 			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword"
-					  << std::endl;
-			return false;
-		}
 		return true;
 	}
 
 	bool parseErrorPages(std::istringstream& iss) {
-		std::string code;
-		std::string tmpStr;
-		std::vector<int> codeList;
-		int codeValue;
-		if (!(iss >> code)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword"
-					  << std::endl;
-			return false;
-		}
-		if (!parseErrorCode(code, codeList))
+		if (!::parseErrorPages(iss, _errorPages))
 			return false;
-		if (!(iss >> tmpStr)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing path after error_page code" << std::endl;
-			return false;
-		}
-		code = tmpStr;
-		while (iss >> tmpStr) {
-			if (!parseErrorCode(code, codeList))
-				return false;
-			code = tmpStr;
-		}
-		for (std::vector<int>::iterator it = codeList.begin(); it != codeList.end(); it++) {
-			codeValue = *it;
-			if (_errorPages.find(codeValue) == _errorPages.end()) {
-				_errorPages[codeValue] =
-					code; // we replace the value only if the key does not exist, else it is the
-						  // first defined error page that is taken into account
-			}
-		}
-		return true;
-	}
-
-	bool parseErrorCode(std::string& code, std::vector<int>& codeList) {
-		int codeValue;
-		size_t idx = code.find_first_not_of("0123456789");
-		if (idx != std::string::npos) {
-			if (code[idx] == '-') {
-				code[idx] = ' ';
-				std::istringstream range(code);
-				int start, end;
-				std::string check;
-				if (!(range >> start >> end)) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page"
-							  << std::endl;
-					return false;
-				}
-				if (range >> check) {
-					std::cerr << CONFIG_FILE_ERROR
-							  << "Too many arguments for code range in error_page" << std::endl;
-					return false;
-				}
-				if (start < 100 || start > 599 || end < 100 || end > 599) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start
-							  << "-" << end << std::endl;
-					return false;
-				}
-				for (int i = start; i <= end; i++)
-					codeList.push_back(i);
-				return true;
-			} else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code
-						  << std::endl;
-				return false;
-			}
-		}
-		codeValue = std::strtol(code.c_str(), NULL, 10);
-		if (codeValue < 100 || codeValue > 599) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid error code: " << codeValue << std::endl;
-			return false;
-		}
-		codeList.push_back(codeValue);
 		return true;
 	}
 
 	bool parseIndex(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword"
-					  << std::endl;
+		if (!::parseIndex(iss, _indexPages))
 			return false;
-		}
-		_indexPages.push_back(value);
-		while (iss >> value)
-			_indexPages.push_back(value);
 		return true;
 	}
 
 	bool parseReturn(std::istringstream& iss) {
-		std::string value;
-		if (_return.first != -1) {
-			std::cerr << CONFIG_FILE_ERROR << "Multiple return instructions" << std::endl;
-			return false;
-		}
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after return keyword"
-					  << std::endl;
+		if (!::parseReturn(iss, _return))
 			return false;
-		}
-		size_t idx = value.find_first_not_of("0123456789");
-		if (idx != std::string::npos) {
-			_return.first = 302;
-			_return.second = value;
-		}
-		else {
-			_return.first = std::strtol(value.c_str(), NULL, 10);
-			if (_return.first == LONG_MAX) {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid value for return code" << std::endl;
-				return false;
-			}
-			if (!(_return.first >= 0 && _return.first <= 599)) {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid return code: " << _return.first
-						  << std::endl;
-				return false;
-			}
-			if (!(iss >> value)) {
-				std::cerr << CONFIG_FILE_ERROR << "Missing redirection url or text after return code" << std::endl;
-				return false;
-			}
-			_return.second = value;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after return keyword"
-					  << std::endl;
-			return false;
-		}
 		return true;
 	}
 

commit 27a7d1f866c28409bdbb176300c655e40c54d7fa
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Fri Jun 9 11:22:20 2023 +0200

    added handling of limit_except directive

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 2ceb276..209136d 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -4,13 +4,14 @@
 
 class Location {
 public:
-	Location(const std::string& rootDir, bool autoIndex, size_t bufferSize, size_t bodySize,
-			 const std::map<int, std::string>& serverErrorPages,
+	Location(const std::string& rootDir, bool autoIndex, const std::map<int, std::string>& serverErrorPages,
 			 const std::vector<std::string>& serverIndexPages, const std::pair<long, std::string>& serverReturn)
 		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex),
-		  _bufferSize(bufferSize), _bodySize(bodySize), _return(-1, ""), _serverErrorPages(serverErrorPages),
+		 	_return(-1, ""), _serverErrorPages(serverErrorPages),
 		  _serverIndexPages(serverIndexPages), _serverReturn(serverReturn) {
 		initKeywordMap();
+		for (int i = 0; i < NO_METHOD; i++)
+			_allowedMethods[i] = true;
 	}
 
 	~Location(){};
@@ -101,9 +102,10 @@ public:
 		std::cout << "URI: " << _uri << std::endl;
 		std::cout << "Root directory: " << _rootDir << std::endl;
 		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
-		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
-		std::cout << "Client max body size: " << _bodySize << std::endl;
 		std::cout << "Return code: " << _return.first << ", url: " << _return.second << std::endl;
+		std::cout << "Allowed methods: " << (_allowedMethods[GET] ? "GET " : "")
+				  << (_allowedMethods[POST] ? "POST " : "")
+				  << (_allowedMethods[DELETE] ? "DELETE " : "") << std::endl;
 		std::cout << "Error pages:" << std::endl;
 		for (std::map<int, std::string>::const_iterator it = _errorPages.begin();
 			 it != _errorPages.end(); it++)
@@ -122,10 +124,8 @@ private:
 	std::string _uri;
 	std::string _rootDir;
 	bool _autoIndex;
-	std::size_t _bufferSize;
-	std::size_t _bodySize;
 	std::pair<long, std::string> _return;
-	std::array<bool, NO_METHOD> _allowedMethods; //NO_METHOD is equivalent to the number of methods in the RequestMethod enum
+	bool _allowedMethods[NO_METHOD]; //NO_METHOD is equivalent to the number of methods in the RequestMethod enum
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
 	const std::map<int, std::string>& _serverErrorPages;
@@ -136,11 +136,10 @@ private:
 	void initKeywordMap() {
 		_keywordHandlers["root"] = &Location::parseRoot;
 		_keywordHandlers["autoindex"] = &Location::parseAutoIndex;
-		_keywordHandlers["client_body_buffer_size"] = &Location::parseClientBodyBufferSize;
-		_keywordHandlers["client_max_body_size"] = &Location::parseClientMaxBodySize;
 		_keywordHandlers["error_page"] = &Location::parseErrorPages;
 		_keywordHandlers["index"] = &Location::parseIndex;
 		_keywordHandlers["return"] = &Location::parseReturn;
+		_keywordHandlers["limit_except"] = &Location::parseMethods;
 	}
 
 	bool parseRoot(std::istringstream& iss) {
@@ -181,118 +180,6 @@ private:
 		return true;
 	}
 
-	bool parseClientBodyBufferSize(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Missing information after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		size_t idx = value.find_first_not_of("0123456789");
-		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		_bufferSize = std::strtol(value.c_str(), NULL, 10);
-		if (_bufferSize == LONG_MAX || _bufferSize == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx])) {
-			case 'k':
-				_bufferSize <<= 10;
-				break;
-			case 'm':
-				_bufferSize <<= 20;
-				break;
-			// case 'g':
-			// 	_bufferSize <<= 30;
-			// 	break;
-			// we do not accept gigabytes as the size would be too large
-			default:
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M"
-						  << std::endl;
-				return false;
-			}
-			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (_bufferSize > BUFFER_SIZE_SERVER_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes"
-					  << std::endl;
-			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Too many arguments after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseClientMaxBodySize(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Missing information after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		size_t idx = value.find_first_not_of("0123456789");
-		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		_bodySize = std::strtol(value.c_str(), NULL, 10);
-		if (_bodySize == LONG_MAX || _bodySize == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx])) {
-			case 'k':
-				_bodySize <<= 10;
-				break;
-			case 'm':
-				_bodySize <<= 20;
-				break;
-			case 'g':
-				_bodySize <<= 30;
-				break;
-			default:
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G"
-						  << std::endl;
-				return false;
-			}
-			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (_bodySize > BODY_SIZE_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT
-					  << " bytes" << std::endl;
-			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Too many arguments after client_max_body_size keyword" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
 	bool parseErrorPages(std::istringstream& iss) {
 		std::string code;
 		std::string tmpStr;
@@ -381,7 +268,7 @@ private:
 		return true;
 	}
 
-		bool parseReturn(std::istringstream& iss) {
+	bool parseReturn(std::istringstream& iss) {
 		std::string value;
 		if (_return.first != -1) {
 			std::cerr << CONFIG_FILE_ERROR << "Multiple return instructions" << std::endl;
@@ -422,7 +309,58 @@ private:
 		return true;
 	}
 
+	bool parseMethods(std::istringstream& iss) {
+		std::string method;
+		if (!(iss >> method)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after limit_except keyword"
+					  << std::endl;
+			return false;
+		}
+		for (int i = 0; i < NO_METHOD; i++)
+			_allowedMethods[i] = false;
+		if (!updateMethod(method))
+			return false;
+		while (iss >> method) {
+			if (!updateMethod(method))
+				return false;
+		}
+		return true;
+	}
 
+	bool updateMethod(std::string const & method) {
+		if (method == "GET")
+		{
+			if (_allowedMethods[GET])
+			{
+				std::cerr << CONFIG_FILE_ERROR << "Multiple GET instructions in limit_except directive" << std::endl;
+				return false;
+			}
+			_allowedMethods[GET] = true;
+		}
+		else if (method == "POST")
+		{
+			if (_allowedMethods[POST])
+			{
+				std::cerr << CONFIG_FILE_ERROR << "Multiple POST instructions in limit_except directive" << std::endl;
+				return false;
+			}
+			_allowedMethods[POST] = true;
+		}
+		else if (method == "DELETE")
+		{
+			if (_allowedMethods[DELETE])
+			{
+				std::cerr << CONFIG_FILE_ERROR << "Multiple DELETE instructions in limit_except directive" << std::endl;
+				return false;
+			}
+			_allowedMethods[DELETE] = true;
+		}
+		else {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid method in limit_except directive: " << method << std::endl;
+			return false;
+		}
+		return true;
+	}
 
 	void checkIndexPages() {
 		if (_indexPages.empty()) {
@@ -433,7 +371,6 @@ private:
 	}
 
 	void checkErrorPages() {
-		// Shouldn't we also check _errorPages.empty() like in checkIndexPages?
 		for (std::map<int, std::string>::const_iterator it = _serverErrorPages.begin();
 			 it != _serverErrorPages.end(); it++) {
 			if (_errorPages.find(it->first) == _errorPages.end())

commit 3fd0159bf01ecf3319767fe212f24ebdc5ac34f2
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Fri Jun 9 10:26:15 2023 +0200

    fixed body size or buffer size equal 0

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 62b8e3b..2ceb276 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -124,9 +124,10 @@ private:
 	bool _autoIndex;
 	std::size_t _bufferSize;
 	std::size_t _bodySize;
+	std::pair<long, std::string> _return;
+	std::array<bool, NO_METHOD> _allowedMethods; //NO_METHOD is equivalent to the number of methods in the RequestMethod enum
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
-	std::pair<long, std::string> _return;
 	const std::map<int, std::string>& _serverErrorPages;
 	const std::vector<std::string>& _serverIndexPages;
 	const std::pair<long, std::string>& _serverReturn;
@@ -194,7 +195,7 @@ private:
 			return false;
 		}
 		_bufferSize = std::strtol(value.c_str(), NULL, 10);
-		if (_bufferSize == LONG_MAX) {
+		if (_bufferSize == LONG_MAX || _bufferSize == 0) {
 			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
 					  << std::endl;
 			return false;
@@ -251,7 +252,7 @@ private:
 			return false;
 		}
 		_bodySize = std::strtol(value.c_str(), NULL, 10);
-		if (_bodySize == LONG_MAX) {
+		if (_bodySize == LONG_MAX || _bodySize == 0) {
 			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
 					  << std::endl;
 			return false;

commit 451dfa25132ab6d55c93c18e5705728d2f934052
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Fri Jun 9 09:38:30 2023 +0200

    added handling of return instruction

diff --git a/includes/Location.hpp b/includes/Location.hpp
index aeebc70..62b8e3b 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -6,10 +6,10 @@ class Location {
 public:
 	Location(const std::string& rootDir, bool autoIndex, size_t bufferSize, size_t bodySize,
 			 const std::map<int, std::string>& serverErrorPages,
-			 const std::vector<std::string>& serverIndexPages)
+			 const std::vector<std::string>& serverIndexPages, const std::pair<long, std::string>& serverReturn)
 		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex),
-		  _bufferSize(bufferSize), _bodySize(bodySize), _serverErrorPages(serverErrorPages),
-		  _serverIndexPages(serverIndexPages) {
+		  _bufferSize(bufferSize), _bodySize(bodySize), _return(-1, ""), _serverErrorPages(serverErrorPages),
+		  _serverIndexPages(serverIndexPages), _serverReturn(serverReturn) {
 		initKeywordMap();
 	}
 
@@ -60,6 +60,7 @@ public:
 			if (keyword == "}") {
 				checkIndexPages();
 				checkErrorPages();
+				checkReturn();
 				return true;
 			} else if (keyword[0] == '#')
 				continue;
@@ -89,6 +90,7 @@ public:
 		case EXACT:
 			return requestPath == _uri ? LOCATION_MATCH_EXACT : LOCATION_MATCH_NONE;
 		}
+		return LOCATION_MATCH_NONE;
 	}
 
 	void printLocationInformation() const {
@@ -101,6 +103,7 @@ public:
 		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
 		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
 		std::cout << "Client max body size: " << _bodySize << std::endl;
+		std::cout << "Return code: " << _return.first << ", url: " << _return.second << std::endl;
 		std::cout << "Error pages:" << std::endl;
 		for (std::map<int, std::string>::const_iterator it = _errorPages.begin();
 			 it != _errorPages.end(); it++)
@@ -123,8 +126,10 @@ private:
 	std::size_t _bodySize;
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
+	std::pair<long, std::string> _return;
 	const std::map<int, std::string>& _serverErrorPages;
 	const std::vector<std::string>& _serverIndexPages;
+	const std::pair<long, std::string>& _serverReturn;
 	std::map<std::string, KeywordHandler> _keywordHandlers;
 
 	void initKeywordMap() {
@@ -134,6 +139,7 @@ private:
 		_keywordHandlers["client_max_body_size"] = &Location::parseClientMaxBodySize;
 		_keywordHandlers["error_page"] = &Location::parseErrorPages;
 		_keywordHandlers["index"] = &Location::parseIndex;
+		_keywordHandlers["return"] = &Location::parseReturn;
 	}
 
 	bool parseRoot(std::istringstream& iss) {
@@ -374,6 +380,49 @@ private:
 		return true;
 	}
 
+		bool parseReturn(std::istringstream& iss) {
+		std::string value;
+		if (_return.first != -1) {
+			std::cerr << CONFIG_FILE_ERROR << "Multiple return instructions" << std::endl;
+			return false;
+		}
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after return keyword"
+					  << std::endl;
+			return false;
+		}
+		size_t idx = value.find_first_not_of("0123456789");
+		if (idx != std::string::npos) {
+			_return.first = 302;
+			_return.second = value;
+		}
+		else {
+			_return.first = std::strtol(value.c_str(), NULL, 10);
+			if (_return.first == LONG_MAX) {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid value for return code" << std::endl;
+				return false;
+			}
+			if (!(_return.first >= 0 && _return.first <= 599)) {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid return code: " << _return.first
+						  << std::endl;
+				return false;
+			}
+			if (!(iss >> value)) {
+				std::cerr << CONFIG_FILE_ERROR << "Missing redirection url or text after return code" << std::endl;
+				return false;
+			}
+			_return.second = value;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after return keyword"
+					  << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+
+
 	void checkIndexPages() {
 		if (_indexPages.empty()) {
 			for (std::vector<std::string>::const_iterator it = _serverIndexPages.begin();
@@ -390,4 +439,9 @@ private:
 				_errorPages[it->first] = it->second;
 		}
 	}
+
+	void checkReturn() {
+		if (_return.first == -1 && _serverReturn.first != -1)
+			_return = _serverReturn;
+	}
 };

commit 127f9be68f615345361f7bda2fd5bdee4f4685e6
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Fri Jun 9 08:35:41 2023 +0200

    fixed the virtual server isMatching function

diff --git a/includes/Location.hpp b/includes/Location.hpp
index a3e6222..aeebc70 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -91,7 +91,6 @@ public:
 		}
 	}
 
-	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
 	void printLocationInformation() const {
 		std::cout << "Location information:" << std::endl;
 		std::cout << "Modifier: "

commit a5e12478d7ef8c46f0e7b97cfd10f44afd290db5
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Fri Jun 9 04:12:02 2023 +0200

    t_vsmatch and other minor fixes

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 60dfa9c..a3e6222 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -79,36 +79,16 @@ public:
 		return false;
 	};
 
-	// the int returned depend on the matching
-	// -2 = exact match
-	// -1 = regex match
-	// 0 = no match
-	// any positive number is a prefix match, the int returned is the length of the matching prefix
-	int isMatching(std::string const& requestPath) const {
-		if (_modifier == EXACT) {
-			if (requestPath == _uri)
-				return -2;
-			else
-				return 0;
-		} else if (_modifier == REGEX) {
-			regex_t reg;
-			int regint;
-
-			if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
-				throw(RegexError());
-			else {
-				regint = regexec(&reg, requestPath.c_str(), 0, NULL, 0);
-				regfree(&reg);
-				if (regint == 0)
-					return -1;
-				else if (regint == REG_NOMATCH)
-					return 0;
-				else
-					throw(RegexError());
-			}
-		} else
+	int isMatching(const std::string& requestPath) const {
+		switch (_modifier) {
+		case NONE:
 			return comparePrefix(_uri, requestPath);
-		return 0;
+		case REGEX:
+			return doesRegexMatch(_uri.c_str(), requestPath.c_str()) ? LOCATION_MATCH_REGEX
+																	 : LOCATION_MATCH_NONE;
+		case EXACT:
+			return requestPath == _uri ? LOCATION_MATCH_EXACT : LOCATION_MATCH_NONE;
+		}
 	}
 
 	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project

commit 71babc4343429fcac0bbb6abb00680c6132f21ce
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Fri Jun 9 01:01:29 2023 +0200

    remove root test.cpp file

diff --git a/includes/Location.hpp b/includes/Location.hpp
index d520b47..60dfa9c 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -84,23 +84,19 @@ public:
 	// -1 = regex match
 	// 0 = no match
 	// any positive number is a prefix match, the int returned is the length of the matching prefix
-	int isMatching(std::string const & requestPath) const {
-		if (_modifier == EXACT)
-		{
+	int isMatching(std::string const& requestPath) const {
+		if (_modifier == EXACT) {
 			if (requestPath == _uri)
 				return -2;
 			else
 				return 0;
-		}
-		else if (_modifier == REGEX)
-		{
+		} else if (_modifier == REGEX) {
 			regex_t reg;
-			int		regint;
-			
+			int regint;
+
 			if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
 				throw(RegexError());
-			else
-			{
+			else {
 				regint = regexec(&reg, requestPath.c_str(), 0, NULL, 0);
 				regfree(&reg);
 				if (regint == 0)
@@ -110,8 +106,7 @@ public:
 				else
 					throw(RegexError());
 			}
-		}
-		else
+		} else
 			return comparePrefix(_uri, requestPath);
 		return 0;
 	}
@@ -222,13 +217,13 @@ private:
 		if (value[idx] != '\0') {
 			switch (std::tolower(value[idx])) {
 			case 'k':
-				_bufferSize *= 1024;
+				_bufferSize <<= 10;
 				break;
 			case 'm':
-				_bufferSize *= 1048576;
+				_bufferSize <<= 20;
 				break;
 			// case 'g':
-			// 	_bufferSize *= 1073741824;
+			// 	_bufferSize <<= 30;
 			// 	break;
 			// we do not accept gigabytes as the size would be too large
 			default:
@@ -279,13 +274,13 @@ private:
 		if (value[idx] != '\0') {
 			switch (std::tolower(value[idx])) {
 			case 'k':
-				_bodySize *= 1024;
+				_bodySize <<= 10;
 				break;
 			case 'm':
-				_bodySize *= 1048576;
+				_bodySize <<= 20;
 				break;
 			case 'g':
-				_bodySize *= 1073741824;
+				_bodySize <<= 30;
 				break;
 			default:
 				std::cerr << CONFIG_FILE_ERROR

commit 03187f4823e3b5e111d0ada0e961b8f3c132fe23
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Thu Jun 8 15:25:42 2023 +0200

    made match check functions for the location

diff --git a/includes/Location.hpp b/includes/Location.hpp
index d36f5a4..d520b47 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -84,46 +84,37 @@ public:
 	// -1 = regex match
 	// 0 = no match
 	// any positive number is a prefix match, the int returned is the length of the matching prefix
-	// int isMatching(const std::string& requestPath) const {
-	// 	if (_modifier == EXACT)
-	// 	{
-	// 		if (requestPath == _uri)
-	// 			return -2;
-	// 		else
-	// 			return 0;
-	// 	}
-	// 	else if (_modifier == REGEX)
-	// 	{
-	// 		regex_t reg;
-	// 		int		regint;
+	int isMatching(std::string const & requestPath) const {
+		if (_modifier == EXACT)
+		{
+			if (requestPath == _uri)
+				return -2;
+			else
+				return 0;
+		}
+		else if (_modifier == REGEX)
+		{
+			regex_t reg;
+			int		regint;
 			
-	// 		if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
-	// 			throw(RegexError());
-	// 		else
-	// 		{
-	// 			regint = regexec(&reg, requestPath.c_str(), 0, NULL, 0);
-	// 			regfree(&reg);
-	// 			if (regint == 0)
-	// 				return -1;
-	// 			else if (regint == REG_NOMATCH)
-	// 				return 0;
-	// 			else
-	// 				throw(RegexError());
-	// 		}
-	// 	}
-	// 	else
-	// 	{
-	// 		if (requestPath.find(_uri) == 0)
-	// 			return _uri.length();
-	// 		else
-	// 			return 0;
-	// 	}
-	// 	else if (_modifier == REGEX) {
-	// 		std::regex regex(_uri);
-	// 		return std::regex_match(uri, regex);
-	// 	} else
-	// 		return uri == _uri;
-	// }
+			if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
+				throw(RegexError());
+			else
+			{
+				regint = regexec(&reg, requestPath.c_str(), 0, NULL, 0);
+				regfree(&reg);
+				if (regint == 0)
+					return -1;
+				else if (regint == REG_NOMATCH)
+					return 0;
+				else
+					throw(RegexError());
+			}
+		}
+		else
+			return comparePrefix(_uri, requestPath);
+		return 0;
+	}
 
 	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
 	void printLocationInformation() const {

commit c4dbb3d955e9c25e098e6f4c5f4ffab31860a1f9
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Thu Jun 8 15:05:48 2023 +0200

    added compare prefix function

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 1b3f511..d36f5a4 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -79,7 +79,7 @@ public:
 		return false;
 	};
 
-	//the int returned depend on the matching
+	// the int returned depend on the matching
 	// -2 = exact match
 	// -1 = regex match
 	// 0 = no match
@@ -98,7 +98,18 @@ public:
 	// 		int		regint;
 			
 	// 		if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
-	// 			throw()
+	// 			throw(RegexError());
+	// 		else
+	// 		{
+	// 			regint = regexec(&reg, requestPath.c_str(), 0, NULL, 0);
+	// 			regfree(&reg);
+	// 			if (regint == 0)
+	// 				return -1;
+	// 			else if (regint == REG_NOMATCH)
+	// 				return 0;
+	// 			else
+	// 				throw(RegexError());
+	// 		}
 	// 	}
 	// 	else
 	// 	{

commit b54bc789384df37789ba3b71a26f2a534aebaf92
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Thu Jun 8 14:54:46 2023 +0200

    added regex error class

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 32bc854..1b3f511 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -79,6 +79,41 @@ public:
 		return false;
 	};
 
+	//the int returned depend on the matching
+	// -2 = exact match
+	// -1 = regex match
+	// 0 = no match
+	// any positive number is a prefix match, the int returned is the length of the matching prefix
+	// int isMatching(const std::string& requestPath) const {
+	// 	if (_modifier == EXACT)
+	// 	{
+	// 		if (requestPath == _uri)
+	// 			return -2;
+	// 		else
+	// 			return 0;
+	// 	}
+	// 	else if (_modifier == REGEX)
+	// 	{
+	// 		regex_t reg;
+	// 		int		regint;
+			
+	// 		if (regcomp(&reg, _uri.c_str(), REG_EXTENDED) != 0)
+	// 			throw()
+	// 	}
+	// 	else
+	// 	{
+	// 		if (requestPath.find(_uri) == 0)
+	// 			return _uri.length();
+	// 		else
+	// 			return 0;
+	// 	}
+	// 	else if (_modifier == REGEX) {
+	// 		std::regex regex(_uri);
+	// 		return std::regex_match(uri, regex);
+	// 	} else
+	// 		return uri == _uri;
+	// }
+
 	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
 	void printLocationInformation() const {
 		std::cout << "Location information:" << std::endl;

commit 793c235fa17c2aca0c0ae43a71f1ca33f5628b31
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Wed Jun 7 17:22:23 2023 +0200

    added closing single quote in location format error message

diff --git a/includes/Location.hpp b/includes/Location.hpp
index d117d15..32bc854 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -19,7 +19,7 @@ public:
 		std::string modifier, uri, check;
 		if (!(iss >> modifier >> uri)) {
 			std::cerr << CONFIG_FILE_ERROR
-					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {'"
 					  << std::endl;
 			return false;
 		}
@@ -39,7 +39,7 @@ public:
 			}
 			if (!(iss >> check)) {
 				std::cerr << CONFIG_FILE_ERROR
-						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {'"
 						  << std::endl;
 				return false;
 			}

commit 74d666f8d21e99e1c84a981cfae7e104b9c58338
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Wed Jun 7 09:13:10 2023 +0200

    no names in prototypes because they are prototypes

diff --git a/includes/Location.hpp b/includes/Location.hpp
index f2b6f50..d117d15 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -102,7 +102,7 @@ public:
 	}
 
 private:
-	typedef bool (Location::*KeywordHandler)(std::istringstream& iss);
+	typedef bool (Location::*KeywordHandler)(std::istringstream&);
 	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;
 	t_modifier _modifier;
 	std::string _uri;

commit f76a2b94f168eefde3f66eb889f776035cf527ac
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Wed Jun 7 07:23:19 2023 +0200

    It compiles but without .cpp classes which is very happy

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 3364c6a..f2b6f50 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -4,17 +4,106 @@
 
 class Location {
 public:
-	Location(VirtualServer* vs);
-	~Location();
+	Location(const std::string& rootDir, bool autoIndex, size_t bufferSize, size_t bodySize,
+			 const std::map<int, std::string>& serverErrorPages,
+			 const std::vector<std::string>& serverIndexPages)
+		: _modifier(NONE), _uri(""), _rootDir(rootDir), _autoIndex(autoIndex),
+		  _bufferSize(bufferSize), _bodySize(bodySize), _serverErrorPages(serverErrorPages),
+		  _serverIndexPages(serverIndexPages) {
+		initKeywordMap();
+	}
 
-	bool initUri(std::istringstream& iss);
-	bool parseLocationContent(std::istream& config);
-	void printLocationInformation() const;
+	~Location(){};
+
+	bool initUri(std::istringstream& iss) {
+		std::string modifier, uri, check;
+		if (!(iss >> modifier >> uri)) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+					  << std::endl;
+			return false;
+		}
+		if (uri == "{") {
+			_uri = modifier;
+			_modifier = NONE;
+		} else {
+			_uri = uri;
+			if (modifier == "~")
+				_modifier = REGEX;
+			else if (modifier == "=")
+				_modifier = EXACT;
+			else {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier
+						  << std::endl;
+				return false;
+			}
+			if (!(iss >> check)) {
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+						  << std::endl;
+				return false;
+			}
+		}
+		if (iss >> check) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments for location" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseLocationContent(std::istream& config) {
+		std::string line, keyword, val;
+		for (; std::getline(config, line);) {
+			std::istringstream iss(line);
+			if (!(iss >> keyword))
+				continue;
+			if (keyword == "}") {
+				checkIndexPages();
+				checkErrorPages();
+				return true;
+			} else if (keyword[0] == '#')
+				continue;
+			else {
+				try {
+					KeywordHandler handler = _keywordHandlers[keyword];
+					if (!(this->*handler)(iss))
+						return false;
+				} catch (const std::exception& e) {
+					std::cerr << CONFIG_FILE_ERROR
+							  << "Invalid keyword in location block: " << keyword << std::endl;
+					return false;
+				}
+			}
+		}
+		std::cerr << CONFIG_FILE_ERROR << "Missing closing bracket for location block" << std::endl;
+		return false;
+	};
+
+	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
+	void printLocationInformation() const {
+		std::cout << "Location information:" << std::endl;
+		std::cout << "Modifier: "
+				  << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact"))
+				  << std::endl;
+		std::cout << "URI: " << _uri << std::endl;
+		std::cout << "Root directory: " << _rootDir << std::endl;
+		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
+		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
+		std::cout << "Client max body size: " << _bodySize << std::endl;
+		std::cout << "Error pages:" << std::endl;
+		for (std::map<int, std::string>::const_iterator it = _errorPages.begin();
+			 it != _errorPages.end(); it++)
+			std::cout << "error " << it->first << ": " << it->second << std::endl;
+		std::cout << "Index pages: ";
+		for (std::vector<std::string>::const_iterator it = _indexPages.begin();
+			 it != _indexPages.end(); it++)
+			std::cout << *it << ", ";
+		std::cout << std::endl;
+	}
 
 private:
 	typedef bool (Location::*KeywordHandler)(std::istringstream& iss);
 	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;
-	VirtualServer* _associatedServer; // TODO const& or const*
 	t_modifier _modifier;
 	std::string _uri;
 	std::string _rootDir;
@@ -23,18 +112,271 @@ private:
 	std::size_t _bodySize;
 	std::map<int, std::string> _errorPages;
 	std::vector<std::string> _indexPages;
-	std::map< std::string, KeywordHandler> _keywordHandlers;
+	const std::map<int, std::string>& _serverErrorPages;
+	const std::vector<std::string>& _serverIndexPages;
+	std::map<std::string, KeywordHandler> _keywordHandlers;
+
+	void initKeywordMap() {
+		_keywordHandlers["root"] = &Location::parseRoot;
+		_keywordHandlers["autoindex"] = &Location::parseAutoIndex;
+		_keywordHandlers["client_body_buffer_size"] = &Location::parseClientBodyBufferSize;
+		_keywordHandlers["client_max_body_size"] = &Location::parseClientMaxBodySize;
+		_keywordHandlers["error_page"] = &Location::parseErrorPages;
+		_keywordHandlers["index"] = &Location::parseIndex;
+	}
+
+	bool parseRoot(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after root keyword" << std::endl;
+			return false;
+		}
+		_rootDir = value;
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after root keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseAutoIndex(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword"
+					  << std::endl;
+			return false;
+		}
+		if (value == "on")
+			_autoIndex = true;
+		else if (value == "off")
+			_autoIndex = false;
+		else {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value
+					  << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword"
+					  << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseClientBodyBufferSize(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Missing information after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		size_t idx = value.find_first_not_of("0123456789");
+		if (idx == 0) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
+					  << std::endl;
+			return false;
+		}
+		_bufferSize = std::strtol(value.c_str(), NULL, 10);
+		if (_bufferSize == LONG_MAX) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
+					  << std::endl;
+			return false;
+		}
+		if (value[idx] != '\0') {
+			switch (std::tolower(value[idx])) {
+			case 'k':
+				_bufferSize *= 1024;
+				break;
+			case 'm':
+				_bufferSize *= 1048576;
+				break;
+			// case 'g':
+			// 	_bufferSize *= 1073741824;
+			// 	break;
+			// we do not accept gigabytes as the size would be too large
+			default:
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M"
+						  << std::endl;
+				return false;
+			}
+			if (value[idx + 1] != '\0') {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
+						  << std::endl;
+				return false;
+			}
+		}
+		if (_bufferSize > BUFFER_SIZE_SERVER_LIMIT) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes"
+					  << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Too many arguments after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseClientMaxBodySize(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Missing information after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		size_t idx = value.find_first_not_of("0123456789");
+		if (idx == 0) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
+					  << std::endl;
+			return false;
+		}
+		_bodySize = std::strtol(value.c_str(), NULL, 10);
+		if (_bodySize == LONG_MAX) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
+					  << std::endl;
+			return false;
+		}
+		if (value[idx] != '\0') {
+			switch (std::tolower(value[idx])) {
+			case 'k':
+				_bodySize *= 1024;
+				break;
+			case 'm':
+				_bodySize *= 1048576;
+				break;
+			case 'g':
+				_bodySize *= 1073741824;
+				break;
+			default:
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G"
+						  << std::endl;
+				return false;
+			}
+			if (value[idx + 1] != '\0') {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
+						  << std::endl;
+				return false;
+			}
+		}
+		if (_bodySize > BODY_SIZE_LIMIT) {
+			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT
+					  << " bytes" << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Too many arguments after client_max_body_size keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseErrorPages(std::istringstream& iss) {
+		std::string code;
+		std::string tmpStr;
+		std::vector<int> codeList;
+		int codeValue;
+		if (!(iss >> code)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword"
+					  << std::endl;
+			return false;
+		}
+		if (!parseErrorCode(code, codeList))
+			return false;
+		if (!(iss >> tmpStr)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing path after error_page code" << std::endl;
+			return false;
+		}
+		code = tmpStr;
+		while (iss >> tmpStr) {
+			if (!parseErrorCode(code, codeList))
+				return false;
+			code = tmpStr;
+		}
+		for (std::vector<int>::iterator it = codeList.begin(); it != codeList.end(); it++) {
+			codeValue = *it;
+			if (_errorPages.find(codeValue) == _errorPages.end()) {
+				_errorPages[codeValue] =
+					code; // we replace the value only if the key does not exist, else it is the
+						  // first defined error page that is taken into account
+			}
+		}
+		return true;
+	}
+
+	bool parseErrorCode(std::string& code, std::vector<int>& codeList) {
+		int codeValue;
+		size_t idx = code.find_first_not_of("0123456789");
+		if (idx != std::string::npos) {
+			if (code[idx] == '-') {
+				code[idx] = ' ';
+				std::istringstream range(code);
+				int start, end;
+				std::string check;
+				if (!(range >> start >> end)) {
+					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page"
+							  << std::endl;
+					return false;
+				}
+				if (range >> check) {
+					std::cerr << CONFIG_FILE_ERROR
+							  << "Too many arguments for code range in error_page" << std::endl;
+					return false;
+				}
+				if (start < 100 || start > 599 || end < 100 || end > 599) {
+					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start
+							  << "-" << end << std::endl;
+					return false;
+				}
+				for (int i = start; i <= end; i++)
+					codeList.push_back(i);
+				return true;
+			} else {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code
+						  << std::endl;
+				return false;
+			}
+		}
+		codeValue = std::strtol(code.c_str(), NULL, 10);
+		if (codeValue < 100 || codeValue > 599) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid error code: " << codeValue << std::endl;
+			return false;
+		}
+		codeList.push_back(codeValue);
+		return true;
+	}
 
-	void initKeywordMap();
+	bool parseIndex(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword"
+					  << std::endl;
+			return false;
+		}
+		_indexPages.push_back(value);
+		while (iss >> value)
+			_indexPages.push_back(value);
+		return true;
+	}
 
-	bool parseRoot(std::istringstream& iss);
-	bool parseAutoIndex(std::istringstream& iss);
-	bool parseClientBodyBufferSize(std::istringstream& iss);
-	bool parseClientMaxBodySize(std::istringstream& iss);
-	bool parseErrorPages(std::istringstream& iss);
-	bool parseErrorCode(std::string& code, std::vector<int>& codeList);
-	bool parseIndex(std::istringstream& iss);
+	void checkIndexPages() {
+		if (_indexPages.empty()) {
+			for (std::vector<std::string>::const_iterator it = _serverIndexPages.begin();
+				 it != _serverIndexPages.end(); it++)
+				_indexPages.push_back(*it);
+		}
+	}
 
-	void checkIndexPages();
-	void checkErrorPages();
+	void checkErrorPages() {
+		// Shouldn't we also check _errorPages.empty() like in checkIndexPages?
+		for (std::map<int, std::string>::const_iterator it = _serverErrorPages.begin();
+			 it != _serverErrorPages.end(); it++) {
+			if (_errorPages.find(it->first) == _errorPages.end())
+				_errorPages[it->first] = it->second;
+		}
+	}
 };

commit 119caeaa8a15023ae45b54d83f5011df1a8e8f71
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Wed Jun 7 06:54:19 2023 +0200

    It compiles but cpp and hpp files are separated this is very sad

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 73451d9..3364c6a 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -1,133 +1,20 @@
 #pragma once
 
-#include <arpa/inet.h>
-#include <climits>
-#include <csignal>
-#include <cstddef>
-#include <cstdio>
-#include <cstdlib>
-#include <cstring>
-#include <exception>
-#include <iostream>
-#include <istream>
-#include <map>
-#include <sstream>
-#include <stdlib.h>
-#include <string>
-#include <sys/epoll.h>
-#include <sys/socket.h>
-#include <vector>
-
-#define BUFFER_SIZE_SERVER_LIMIT 1048576 // 1MB
-#define BODY_SIZE_LIMIT 1073741824		 // 1GB
-#define CONFIG_FILE_ERROR "Error in configuration file: "
-
-bool getIPvalue(std::string& IP, uint32_t& res); // TODO : understand why I need this prototype here
-												 // while it already exists in weverserv.hpp
-class VirtualServer;
+#include "webserv.hpp"
 
 class Location {
-
 public:
-	Location(VirtualServer& vs)
-		: _associatedServer(vs), _modifier(NONE), _uri(""), _rootDir(vs.getRootDir()),
-		  _autoIndex(vs.getAutoIndex()), _bufferSize(vs.getBufferSize()),
-		  _bodySize(vs.getBodySize()) {
-		initKeywordMap();
-	}
-
-	~Location(){};
+	Location(VirtualServer* vs);
+	~Location();
 
-	bool initUri(std::istringstream& iss) {
-		std::string modifier, uri, check;
-		if (!(iss >> modifier >> uri)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
-					  << std::endl;
-			return false;
-		}
-		if (uri == "{") {
-			_uri = modifier;
-			_modifier = NONE;
-		} else {
-			_uri = uri;
-			if (modifier == "~")
-				_modifier = REGEX;
-			else if (modifier == "=")
-				_modifier = EXACT;
-			else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier
-						  << std::endl;
-				return false;
-			}
-			if (!(iss >> check)) {
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (iss >> check) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments for location" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseLocationContent(std::istream& config) {
-		std::string line, keyword, val;
-		for (; std::getline(config, line);) {
-			std::istringstream iss(line);
-			if (!(iss >> keyword))
-				continue;
-			if (keyword == "}") {
-				checkIndexPages();
-				checkErrorPages();
-				return true;
-			} else if (keyword[0] == '#')
-				continue;
-			else {
-				try {
-					KeywordHandler handler = _keywordHandlers.at(keyword);
-					if (!(this->*handler)(iss))
-						return false;
-				} catch (const std::exception& e) {
-					std::cerr << CONFIG_FILE_ERROR
-							  << "Invalid keyword in location block: " << keyword << std::endl;
-					return false;
-				}
-			}
-		}
-		std::cerr << CONFIG_FILE_ERROR << "Missing closing bracket for location block" << std::endl;
-		return false;
-	};
-
-	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
-	void printLocationInformation(void) {
-		std::cout << "Location information:" << std::endl;
-		std::cout << "Modifier: "
-				  << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact"))
-				  << std::endl;
-		std::cout << "URI: " << _uri << std::endl;
-		std::cout << "Root directory: " << _rootDir << std::endl;
-		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
-		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
-		std::cout << "Client max body size: " << _bodySize << std::endl;
-		std::cout << "Error pages:" << std::endl;
-		for (std::map<int, std::string>::iterator it = _errorPages.begin(); it != _errorPages.end();
-			 it++)
-			std::cout << "error " << it->first << ": " << it->second << std::endl;
-		std::cout << "Index pages: ";
-		for (std::vector<std::string>::iterator it = _indexPages.begin(); it != _indexPages.end();
-			 it++)
-			std::cout << *it << ", ";
-		std::cout << std::endl;
-	}
+	bool initUri(std::istringstream& iss);
+	bool parseLocationContent(std::istream& config);
+	void printLocationInformation() const;
 
 private:
 	typedef bool (Location::*KeywordHandler)(std::istringstream& iss);
 	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;
-	VirtualServer& _associatedServer;
+	VirtualServer* _associatedServer; // TODO const& or const*
 	t_modifier _modifier;
 	std::string _uri;
 	std::string _rootDir;
@@ -138,266 +25,16 @@ private:
 	std::vector<std::string> _indexPages;
 	std::map< std::string, KeywordHandler> _keywordHandlers;
 
-	void initKeywordMap(void) {
-		_keywordHandlers["root"] = &Location::parseRoot;
-		_keywordHandlers["autoindex"] = &Location::parseAutoIndex;
-		_keywordHandlers["client_body_buffer_size"] = &Location::parseClientBodyBufferSize;
-		_keywordHandlers["client_max_body_size"] = &Location::parseClientMaxBodySize;
-		_keywordHandlers["error_page"] = &Location::parseErrorPages;
-		_keywordHandlers["index"] = &Location::parseIndex;
-	}
-
-	bool parseRoot(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after root keyword" << std::endl;
-			return false;
-		}
-		_rootDir = value;
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after root keyword" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseAutoIndex(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword"
-					  << std::endl;
-			return false;
-		}
-		if (value == "on")
-			_autoIndex = true;
-		else if (value == "off")
-			_autoIndex = false;
-		else {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value
-					  << std::endl;
-			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword"
-					  << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseClientBodyBufferSize(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Missing information after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		size_t idx = value.find_first_not_of("0123456789");
-		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		_bufferSize = std::strtol(value.c_str(), NULL, 10);
-		if (_bufferSize == LONG_MAX) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx])) {
-			case 'k':
-				_bufferSize *= 1024;
-				break;
-			case 'm':
-				_bufferSize *= 1048576;
-				break;
-			// case 'g':
-			// 	_bufferSize *= 1073741824;
-			// 	break;
-			// we do not accept gigabytes as the size would be too large
-			default:
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M"
-						  << std::endl;
-				return false;
-			}
-			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (_bufferSize > BUFFER_SIZE_SERVER_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes"
-					  << std::endl;
-			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Too many arguments after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseClientMaxBodySize(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Missing information after client_body_buffer_size keyword" << std::endl;
-			return false;
-		}
-		size_t idx = value.find_first_not_of("0123456789");
-		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		_bodySize = std::strtol(value.c_str(), NULL, 10);
-		if (_bodySize == LONG_MAX) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
-					  << std::endl;
-			return false;
-		}
-		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx])) {
-			case 'k':
-				_bodySize *= 1024;
-				break;
-			case 'm':
-				_bodySize *= 1048576;
-				break;
-			case 'g':
-				_bodySize *= 1073741824;
-				break;
-			default:
-				std::cerr << CONFIG_FILE_ERROR
-						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G"
-						  << std::endl;
-				return false;
-			}
-			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
-						  << std::endl;
-				return false;
-			}
-		}
-		if (_bodySize > BODY_SIZE_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT
-					  << " bytes" << std::endl;
-			return false;
-		}
-		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR
-					  << "Too many arguments after client_max_body_size keyword" << std::endl;
-			return false;
-		}
-		return true;
-	}
-
-	bool parseErrorPages(std::istringstream& iss) {
-		std::string code;
-		std::string tmpStr;
-		std::vector<int> codeList;
-		int codeValue;
-		if (!(iss >> code)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword"
-					  << std::endl;
-			return false;
-		}
-		if (!parseErrorCode(code, codeList))
-			return false;
-		if (!(iss >> tmpStr)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing path after error_page code" << std::endl;
-			return false;
-		}
-		code = tmpStr;
-		while (iss >> tmpStr) {
-			if (!parseErrorCode(code, codeList))
-				return false;
-			code = tmpStr;
-		}
-		for (std::vector<int>::iterator it = codeList.begin(); it != codeList.end(); it++) {
-			codeValue = *it;
-			if (_errorPages.find(codeValue) == _errorPages.end()) {
-				_errorPages[codeValue] =
-					code; // we replace the value only if the key does not exist, else it is the
-						  // first defined error page that is taken into account
-			}
-		}
-		return true;
-	}
-
-	bool parseErrorCode(std::string& code, std::vector<int>& codeList) {
-		int codeValue;
-		size_t idx = code.find_first_not_of("0123456789");
-		if (idx != std::string::npos) {
-			if (code[idx] == '-') {
-				code[idx] = ' ';
-				std::istringstream range(code);
-				int start, end;
-				std::string check;
-				if (!(range >> start >> end)) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page"
-							  << std::endl;
-					return false;
-				}
-				if (range >> check) {
-					std::cerr << CONFIG_FILE_ERROR
-							  << "Too many arguments for code range in error_page" << std::endl;
-					return false;
-				}
-				if (start < 100 || start > 599 || end < 100 || end > 599) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start
-							  << "-" << end << std::endl;
-					return false;
-				}
-				for (int i = start; i <= end; i++)
-					codeList.push_back(i);
-				return true;
-			} else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code
-						  << std::endl;
-				return false;
-			}
-		}
-		codeValue = std::strtol(code.c_str(), NULL, 10);
-		if (codeValue < 100 || codeValue > 599) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid error code: " << codeValue << std::endl;
-			return false;
-		}
-		codeList.push_back(codeValue);
-		return true;
-	}
-
-	bool parseIndex(std::istringstream& iss) {
-		std::string value;
-		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword"
-					  << std::endl;
-			return false;
-		}
-		_indexPages.push_back(value);
-		while (iss >> value)
-			_indexPages.push_back(value);
-		return true;
-	}
+	void initKeywordMap();
 
-	void checkIndexPages(void) {
-		if (_indexPages.empty()) {
-			for (std::vector<std::string>::iterator it = _associatedServer.getIndexPages().begin();
-				 it != _associatedServer.getIndexPages().end(); it++)
-				_indexPages.push_back(*it);
-		}
-	}
+	bool parseRoot(std::istringstream& iss);
+	bool parseAutoIndex(std::istringstream& iss);
+	bool parseClientBodyBufferSize(std::istringstream& iss);
+	bool parseClientMaxBodySize(std::istringstream& iss);
+	bool parseErrorPages(std::istringstream& iss);
+	bool parseErrorCode(std::string& code, std::vector<int>& codeList);
+	bool parseIndex(std::istringstream& iss);
 
-	void checkErrorPages(void) {
-		for (std::map<int, std::string>::iterator it = _associatedServer.getErrorPages().begin();
-			 it != _associatedServer.getErrorPages().end(); it++) {
-			if (_errorPages.find(it->first) == _errorPages.end())
-				_errorPages[it->first] = it->second;
-		}
-	}
+	void checkIndexPages();
+	void checkErrorPages();
 };

commit 991a20671b9689ee1e6d0bd4603d04c8fb91285f
Author: norxondor_gorgonax <axel.brisse@gmail.com>
Date:   Wed Jun 7 01:12:58 2023 +0200

    still wip: format everything

diff --git a/includes/Location.hpp b/includes/Location.hpp
index f900668..73451d9 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -19,16 +19,20 @@
 #include <vector>
 
 #define BUFFER_SIZE_SERVER_LIMIT 1048576 // 1MB
-#define BODY_SIZE_LIMIT 1073741824 // 1GB
+#define BODY_SIZE_LIMIT 1073741824		 // 1GB
 #define CONFIG_FILE_ERROR "Error in configuration file: "
 
-bool getIPvalue(std::string &IP, uint32_t &res); // TODO : understand why I need this prototype here while it already exists in weverserv.hpp
+bool getIPvalue(std::string& IP, uint32_t& res); // TODO : understand why I need this prototype here
+												 // while it already exists in weverserv.hpp
 class VirtualServer;
 
 class Location {
 
 public:
-	Location(VirtualServer& vs): _associatedServer(vs), _modifier(NONE), _uri(""), _rootDir(vs.getRootDir()), _autoIndex(vs.getAutoIndex()), _bufferSize(vs.getBufferSize()), _bodySize(vs.getBodySize()) {
+	Location(VirtualServer& vs)
+		: _associatedServer(vs), _modifier(NONE), _uri(""), _rootDir(vs.getRootDir()),
+		  _autoIndex(vs.getAutoIndex()), _bufferSize(vs.getBufferSize()),
+		  _bodySize(vs.getBodySize()) {
 		initKeywordMap();
 	}
 
@@ -37,25 +41,29 @@ public:
 	bool initUri(std::istringstream& iss) {
 		std::string modifier, uri, check;
 		if (!(iss >> modifier >> uri)) {
-			std::cerr << CONFIG_FILE_ERROR << "Wrong syntax for location, syntax must be 'location [modifier] uri {" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+					  << std::endl;
 			return false;
 		}
 		if (uri == "{") {
 			_uri = modifier;
 			_modifier = NONE;
-		}
-		else {
+		} else {
 			_uri = uri;
 			if (modifier == "~")
 				_modifier = REGEX;
 			else if (modifier == "=")
 				_modifier = EXACT;
 			else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier << std::endl;
+				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier
+						  << std::endl;
 				return false;
 			}
 			if (!(iss >> check)) {
-				std::cerr << CONFIG_FILE_ERROR << "Wrong syntax for location, syntax must be 'location [modifier] uri {" << std::endl;
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Wrong syntax for location, syntax must be 'location [modifier] uri {"
+						  << std::endl;
 				return false;
 			}
 		}
@@ -72,13 +80,11 @@ public:
 			std::istringstream iss(line);
 			if (!(iss >> keyword))
 				continue;
-			if (keyword == "}")
-			{
+			if (keyword == "}") {
 				checkIndexPages();
 				checkErrorPages();
 				return true;
-			}
-			else if (keyword[0] == '#')
+			} else if (keyword[0] == '#')
 				continue;
 			else {
 				try {
@@ -86,7 +92,8 @@ public:
 					if (!(this->*handler)(iss))
 						return false;
 				} catch (const std::exception& e) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid keyword in location block: " << keyword << std::endl;
+					std::cerr << CONFIG_FILE_ERROR
+							  << "Invalid keyword in location block: " << keyword << std::endl;
 					return false;
 				}
 			}
@@ -96,30 +103,30 @@ public:
 	};
 
 	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
-	void	printLocationInformation(void) {
+	void printLocationInformation(void) {
 		std::cout << "Location information:" << std::endl;
-		std::cout << "Modifier: " << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact")) << std::endl;
+		std::cout << "Modifier: "
+				  << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact"))
+				  << std::endl;
 		std::cout << "URI: " << _uri << std::endl;
 		std::cout << "Root directory: " << _rootDir << std::endl;
 		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
 		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
 		std::cout << "Client max body size: " << _bodySize << std::endl;
 		std::cout << "Error pages:" << std::endl;
-		for (std::map<int, std::string>::iterator it = _errorPages.begin(); it != _errorPages.end(); it++)
+		for (std::map<int, std::string>::iterator it = _errorPages.begin(); it != _errorPages.end();
+			 it++)
 			std::cout << "error " << it->first << ": " << it->second << std::endl;
 		std::cout << "Index pages: ";
-		for (std::vector<std::string>::iterator it = _indexPages.begin(); it != _indexPages.end(); it++)
+		for (std::vector<std::string>::iterator it = _indexPages.begin(); it != _indexPages.end();
+			 it++)
 			std::cout << *it << ", ";
 		std::cout << std::endl;
 	}
 
 private:
 	typedef bool (Location::*KeywordHandler)(std::istringstream& iss);
-	typedef enum e_modifier {
-		NONE,
-		REGEX,
-		EXACT
-	} t_modifier;
+	typedef enum e_modifier { NONE, REGEX, EXACT } t_modifier;
 	VirtualServer& _associatedServer;
 	t_modifier _modifier;
 	std::string _uri;
@@ -139,7 +146,7 @@ private:
 		_keywordHandlers["error_page"] = &Location::parseErrorPages;
 		_keywordHandlers["index"] = &Location::parseIndex;
 	}
-	
+
 	bool parseRoot(std::istringstream& iss) {
 		std::string value;
 		if (!(iss >> value)) {
@@ -157,7 +164,8 @@ private:
 	bool parseAutoIndex(std::istringstream& iss) {
 		std::string value;
 		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword"
+					  << std::endl;
 			return false;
 		}
 		if (value == "on")
@@ -165,11 +173,13 @@ private:
 		else if (value == "off")
 			_autoIndex = false;
 		else {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value
+					  << std::endl;
 			return false;
 		}
 		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword"
+					  << std::endl;
 			return false;
 		}
 		return true;
@@ -178,22 +188,24 @@ private:
 	bool parseClientBodyBufferSize(std::istringstream& iss) {
 		std::string value;
 		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after client_body_buffer_size keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Missing information after client_body_buffer_size keyword" << std::endl;
 			return false;
 		}
 		size_t idx = value.find_first_not_of("0123456789");
 		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
+					  << std::endl;
 			return false;
 		}
 		_bufferSize = std::strtol(value.c_str(), NULL, 10);
 		if (_bufferSize == LONG_MAX) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
+					  << std::endl;
 			return false;
 		}
 		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx]))
-			{
+			switch (std::tolower(value[idx])) {
 			case 'k':
 				_bufferSize *= 1024;
 				break;
@@ -205,20 +217,26 @@ private:
 			// 	break;
 			// we do not accept gigabytes as the size would be too large
 			default:
-				std::cerr << CONFIG_FILE_ERROR << "Invalid suffix for bytes value, valid suffix are: k, K, m, M" << std::endl;
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M"
+						  << std::endl;
 				return false;
 			}
 			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value" << std::endl;
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
+						  << std::endl;
 				return false;
 			}
 		}
 		if (_bufferSize > BUFFER_SIZE_SERVER_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes"
+					  << std::endl;
 			return false;
 		}
 		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after client_body_buffer_size keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Too many arguments after client_body_buffer_size keyword" << std::endl;
 			return false;
 		}
 		return true;
@@ -227,22 +245,24 @@ private:
 	bool parseClientMaxBodySize(std::istringstream& iss) {
 		std::string value;
 		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after client_body_buffer_size keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Missing information after client_body_buffer_size keyword" << std::endl;
 			return false;
 		}
 		size_t idx = value.find_first_not_of("0123456789");
 		if (idx == 0) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size"
+					  << std::endl;
 			return false;
 		}
 		_bodySize = std::strtol(value.c_str(), NULL, 10);
 		if (_bodySize == LONG_MAX) {
-			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size"
+					  << std::endl;
 			return false;
 		}
 		if (value[idx] != '\0') {
-			switch (std::tolower(value[idx]))
-			{
+			switch (std::tolower(value[idx])) {
 			case 'k':
 				_bodySize *= 1024;
 				break;
@@ -253,20 +273,25 @@ private:
 				_bodySize *= 1073741824;
 				break;
 			default:
-				std::cerr << CONFIG_FILE_ERROR << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G" << std::endl;
+				std::cerr << CONFIG_FILE_ERROR
+						  << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G"
+						  << std::endl;
 				return false;
 			}
 			if (value[idx + 1] != '\0') {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value" << std::endl;
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value"
+						  << std::endl;
 				return false;
 			}
 		}
 		if (_bodySize > BODY_SIZE_LIMIT) {
-			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT << " bytes" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT
+					  << " bytes" << std::endl;
 			return false;
 		}
 		if (iss >> value) {
-			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after client_max_body_size keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR
+					  << "Too many arguments after client_max_body_size keyword" << std::endl;
 			return false;
 		}
 		return true;
@@ -278,7 +303,8 @@ private:
 		std::vector<int> codeList;
 		int codeValue;
 		if (!(iss >> code)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword"
+					  << std::endl;
 			return false;
 		}
 		if (!parseErrorCode(code, codeList))
@@ -296,13 +322,15 @@ private:
 		for (std::vector<int>::iterator it = codeList.begin(); it != codeList.end(); it++) {
 			codeValue = *it;
 			if (_errorPages.find(codeValue) == _errorPages.end()) {
-				_errorPages[codeValue] = code; // we replace the value only if the key does not exist, else it is the first defined error page that is taken into account
+				_errorPages[codeValue] =
+					code; // we replace the value only if the key does not exist, else it is the
+						  // first defined error page that is taken into account
 			}
 		}
 		return true;
 	}
 
-	bool parseErrorCode(std::string &code, std::vector<int> &codeList) {
+	bool parseErrorCode(std::string& code, std::vector<int>& codeList) {
 		int codeValue;
 		size_t idx = code.find_first_not_of("0123456789");
 		if (idx != std::string::npos) {
@@ -312,23 +340,26 @@ private:
 				int start, end;
 				std::string check;
 				if (!(range >> start >> end)) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page" << std::endl;
+					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page"
+							  << std::endl;
 					return false;
 				}
 				if (range >> check) {
-					std::cerr << CONFIG_FILE_ERROR << "Too many arguments for code range in error_page" << std::endl;
+					std::cerr << CONFIG_FILE_ERROR
+							  << "Too many arguments for code range in error_page" << std::endl;
 					return false;
 				}
 				if (start < 100 || start > 599 || end < 100 || end > 599) {
-					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start << "-" << end << std::endl;
+					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start
+							  << "-" << end << std::endl;
 					return false;
 				}
 				for (int i = start; i <= end; i++)
 					codeList.push_back(i);
 				return true;
-			}
-			else {
-				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code << std::endl;
+			} else {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code
+						  << std::endl;
 				return false;
 			}
 		}
@@ -344,7 +375,8 @@ private:
 	bool parseIndex(std::istringstream& iss) {
 		std::string value;
 		if (!(iss >> value)) {
-			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword" << std::endl;
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword"
+					  << std::endl;
 			return false;
 		}
 		_indexPages.push_back(value);
@@ -355,13 +387,15 @@ private:
 
 	void checkIndexPages(void) {
 		if (_indexPages.empty()) {
-			for (std::vector<std::string>::iterator it = _associatedServer.getIndexPages().begin(); it != _associatedServer.getIndexPages().end(); it++)
+			for (std::vector<std::string>::iterator it = _associatedServer.getIndexPages().begin();
+				 it != _associatedServer.getIndexPages().end(); it++)
 				_indexPages.push_back(*it);
 		}
 	}
 
 	void checkErrorPages(void) {
-		for (std::map<int, std::string>::iterator it = _associatedServer.getErrorPages().begin(); it != _associatedServer.getErrorPages().end(); it++) {
+		for (std::map<int, std::string>::iterator it = _associatedServer.getErrorPages().begin();
+			 it != _associatedServer.getErrorPages().end(); it++) {
 			if (_errorPages.find(it->first) == _errorPages.end())
 				_errorPages[it->first] = it->second;
 		}

commit a5b78aec0226ac0659500d320105178b5adbfd85
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Tue Jun 6 20:27:25 2023 +0200

    WIP : parsing location, not working due to circular references

diff --git a/includes/Location.hpp b/includes/Location.hpp
index c91a622..f900668 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -1,6 +1,369 @@
 #pragma once
 
+#include <arpa/inet.h>
+#include <climits>
+#include <csignal>
+#include <cstddef>
+#include <cstdio>
+#include <cstdlib>
+#include <cstring>
+#include <exception>
+#include <iostream>
+#include <istream>
+#include <map>
+#include <sstream>
+#include <stdlib.h>
+#include <string>
+#include <sys/epoll.h>
+#include <sys/socket.h>
+#include <vector>
+
+#define BUFFER_SIZE_SERVER_LIMIT 1048576 // 1MB
+#define BODY_SIZE_LIMIT 1073741824 // 1GB
+#define CONFIG_FILE_ERROR "Error in configuration file: "
+
+bool getIPvalue(std::string &IP, uint32_t &res); // TODO : understand why I need this prototype here while it already exists in weverserv.hpp
+class VirtualServer;
+
 class Location {
+
 public:
+	Location(VirtualServer& vs): _associatedServer(vs), _modifier(NONE), _uri(""), _rootDir(vs.getRootDir()), _autoIndex(vs.getAutoIndex()), _bufferSize(vs.getBufferSize()), _bodySize(vs.getBodySize()) {
+		initKeywordMap();
+	}
+
+	~Location(){};
+
+	bool initUri(std::istringstream& iss) {
+		std::string modifier, uri, check;
+		if (!(iss >> modifier >> uri)) {
+			std::cerr << CONFIG_FILE_ERROR << "Wrong syntax for location, syntax must be 'location [modifier] uri {" << std::endl;
+			return false;
+		}
+		if (uri == "{") {
+			_uri = modifier;
+			_modifier = NONE;
+		}
+		else {
+			_uri = uri;
+			if (modifier == "~")
+				_modifier = REGEX;
+			else if (modifier == "=")
+				_modifier = EXACT;
+			else {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid modifier for location: " << modifier << std::endl;
+				return false;
+			}
+			if (!(iss >> check)) {
+				std::cerr << CONFIG_FILE_ERROR << "Wrong syntax for location, syntax must be 'location [modifier] uri {" << std::endl;
+				return false;
+			}
+		}
+		if (iss >> check) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments for location" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseLocationContent(std::istream& config) {
+		std::string line, keyword, val;
+		for (; std::getline(config, line);) {
+			std::istringstream iss(line);
+			if (!(iss >> keyword))
+				continue;
+			if (keyword == "}")
+			{
+				checkIndexPages();
+				checkErrorPages();
+				return true;
+			}
+			else if (keyword[0] == '#')
+				continue;
+			else {
+				try {
+					KeywordHandler handler = _keywordHandlers.at(keyword);
+					if (!(this->*handler)(iss))
+						return false;
+				} catch (const std::exception& e) {
+					std::cerr << CONFIG_FILE_ERROR << "Invalid keyword in location block: " << keyword << std::endl;
+					return false;
+				}
+			}
+		}
+		std::cerr << CONFIG_FILE_ERROR << "Missing closing bracket for location block" << std::endl;
+		return false;
+	};
+
+	// TODO : delete this function as it uses inet_ntoa which is not allowed for the project
+	void	printLocationInformation(void) {
+		std::cout << "Location information:" << std::endl;
+		std::cout << "Modifier: " << (_modifier == NONE ? "none" : (_modifier == REGEX ? "regex" : "exact")) << std::endl;
+		std::cout << "URI: " << _uri << std::endl;
+		std::cout << "Root directory: " << _rootDir << std::endl;
+		std::cout << "Autoindex: " << (_autoIndex ? "on" : "off") << std::endl;
+		std::cout << "Client body buffer size: " << _bufferSize << std::endl;
+		std::cout << "Client max body size: " << _bodySize << std::endl;
+		std::cout << "Error pages:" << std::endl;
+		for (std::map<int, std::string>::iterator it = _errorPages.begin(); it != _errorPages.end(); it++)
+			std::cout << "error " << it->first << ": " << it->second << std::endl;
+		std::cout << "Index pages: ";
+		for (std::vector<std::string>::iterator it = _indexPages.begin(); it != _indexPages.end(); it++)
+			std::cout << *it << ", ";
+		std::cout << std::endl;
+	}
+
 private:
-};
\ No newline at end of file
+	typedef bool (Location::*KeywordHandler)(std::istringstream& iss);
+	typedef enum e_modifier {
+		NONE,
+		REGEX,
+		EXACT
+	} t_modifier;
+	VirtualServer& _associatedServer;
+	t_modifier _modifier;
+	std::string _uri;
+	std::string _rootDir;
+	bool _autoIndex;
+	std::size_t _bufferSize;
+	std::size_t _bodySize;
+	std::map<int, std::string> _errorPages;
+	std::vector<std::string> _indexPages;
+	std::map< std::string, KeywordHandler> _keywordHandlers;
+
+	void initKeywordMap(void) {
+		_keywordHandlers["root"] = &Location::parseRoot;
+		_keywordHandlers["autoindex"] = &Location::parseAutoIndex;
+		_keywordHandlers["client_body_buffer_size"] = &Location::parseClientBodyBufferSize;
+		_keywordHandlers["client_max_body_size"] = &Location::parseClientMaxBodySize;
+		_keywordHandlers["error_page"] = &Location::parseErrorPages;
+		_keywordHandlers["index"] = &Location::parseIndex;
+	}
+	
+	bool parseRoot(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after root keyword" << std::endl;
+			return false;
+		}
+		_rootDir = value;
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after root keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseAutoIndex(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after autoindex keyword" << std::endl;
+			return false;
+		}
+		if (value == "on")
+			_autoIndex = true;
+		else if (value == "off")
+			_autoIndex = false;
+		else {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for autoindex keyword: " << value << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after autoindex keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseClientBodyBufferSize(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		size_t idx = value.find_first_not_of("0123456789");
+		if (idx == 0) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size" << std::endl;
+			return false;
+		}
+		_bufferSize = std::strtol(value.c_str(), NULL, 10);
+		if (_bufferSize == LONG_MAX) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size" << std::endl;
+			return false;
+		}
+		if (value[idx] != '\0') {
+			switch (std::tolower(value[idx]))
+			{
+			case 'k':
+				_bufferSize *= 1024;
+				break;
+			case 'm':
+				_bufferSize *= 1048576;
+				break;
+			// case 'g':
+			// 	_bufferSize *= 1073741824;
+			// 	break;
+			// we do not accept gigabytes as the size would be too large
+			default:
+				std::cerr << CONFIG_FILE_ERROR << "Invalid suffix for bytes value, valid suffix are: k, K, m, M" << std::endl;
+				return false;
+			}
+			if (value[idx + 1] != '\0') {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value" << std::endl;
+				return false;
+			}
+		}
+		if (_bufferSize > BUFFER_SIZE_SERVER_LIMIT) {
+			std::cerr << CONFIG_FILE_ERROR << "Buffer size too big, maximum is: " << BUFFER_SIZE_SERVER_LIMIT << " bytes" << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseClientMaxBodySize(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after client_body_buffer_size keyword" << std::endl;
+			return false;
+		}
+		size_t idx = value.find_first_not_of("0123456789");
+		if (idx == 0) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid character for client_body_buffer_size" << std::endl;
+			return false;
+		}
+		_bodySize = std::strtol(value.c_str(), NULL, 10);
+		if (_bodySize == LONG_MAX) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid value for client_body_buffer_size" << std::endl;
+			return false;
+		}
+		if (value[idx] != '\0') {
+			switch (std::tolower(value[idx]))
+			{
+			case 'k':
+				_bodySize *= 1024;
+				break;
+			case 'm':
+				_bodySize *= 1048576;
+				break;
+			case 'g':
+				_bodySize *= 1073741824;
+				break;
+			default:
+				std::cerr << CONFIG_FILE_ERROR << "Invalid suffix for bytes value, valid suffix are: k, K, m, M, g, G" << std::endl;
+				return false;
+			}
+			if (value[idx + 1] != '\0') {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character after suffix for bytes value" << std::endl;
+				return false;
+			}
+		}
+		if (_bodySize > BODY_SIZE_LIMIT) {
+			std::cerr << CONFIG_FILE_ERROR << "Body size too big, maximum is: " << BODY_SIZE_LIMIT << " bytes" << std::endl;
+			return false;
+		}
+		if (iss >> value) {
+			std::cerr << CONFIG_FILE_ERROR << "Too many arguments after client_max_body_size keyword" << std::endl;
+			return false;
+		}
+		return true;
+	}
+
+	bool parseErrorPages(std::istringstream& iss) {
+		std::string code;
+		std::string tmpStr;
+		std::vector<int> codeList;
+		int codeValue;
+		if (!(iss >> code)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after error_page keyword" << std::endl;
+			return false;
+		}
+		if (!parseErrorCode(code, codeList))
+			return false;
+		if (!(iss >> tmpStr)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing path after error_page code" << std::endl;
+			return false;
+		}
+		code = tmpStr;
+		while (iss >> tmpStr) {
+			if (!parseErrorCode(code, codeList))
+				return false;
+			code = tmpStr;
+		}
+		for (std::vector<int>::iterator it = codeList.begin(); it != codeList.end(); it++) {
+			codeValue = *it;
+			if (_errorPages.find(codeValue) == _errorPages.end()) {
+				_errorPages[codeValue] = code; // we replace the value only if the key does not exist, else it is the first defined error page that is taken into account
+			}
+		}
+		return true;
+	}
+
+	bool parseErrorCode(std::string &code, std::vector<int> &codeList) {
+		int codeValue;
+		size_t idx = code.find_first_not_of("0123456789");
+		if (idx != std::string::npos) {
+			if (code[idx] == '-') {
+				code[idx] = ' ';
+				std::istringstream range(code);
+				int start, end;
+				std::string check;
+				if (!(range >> start >> end)) {
+					std::cerr << CONFIG_FILE_ERROR << "Invalid format for code range in error_page" << std::endl;
+					return false;
+				}
+				if (range >> check) {
+					std::cerr << CONFIG_FILE_ERROR << "Too many arguments for code range in error_page" << std::endl;
+					return false;
+				}
+				if (start < 100 || start > 599 || end < 100 || end > 599) {
+					std::cerr << CONFIG_FILE_ERROR << "Invalid error code in range: " << start << "-" << end << std::endl;
+					return false;
+				}
+				for (int i = start; i <= end; i++)
+					codeList.push_back(i);
+				return true;
+			}
+			else {
+				std::cerr << CONFIG_FILE_ERROR << "Invalid character in error code: " << code << std::endl;
+				return false;
+			}
+		}
+		codeValue = std::strtol(code.c_str(), NULL, 10);
+		if (codeValue < 100 || codeValue > 599) {
+			std::cerr << CONFIG_FILE_ERROR << "Invalid error code: " << codeValue << std::endl;
+			return false;
+		}
+		codeList.push_back(codeValue);
+		return true;
+	}
+
+	bool parseIndex(std::istringstream& iss) {
+		std::string value;
+		if (!(iss >> value)) {
+			std::cerr << CONFIG_FILE_ERROR << "Missing information after index keyword" << std::endl;
+			return false;
+		}
+		_indexPages.push_back(value);
+		while (iss >> value)
+			_indexPages.push_back(value);
+		return true;
+	}
+
+	void checkIndexPages(void) {
+		if (_indexPages.empty()) {
+			for (std::vector<std::string>::iterator it = _associatedServer.getIndexPages().begin(); it != _associatedServer.getIndexPages().end(); it++)
+				_indexPages.push_back(*it);
+		}
+	}
+
+	void checkErrorPages(void) {
+		for (std::map<int, std::string>::iterator it = _associatedServer.getErrorPages().begin(); it != _associatedServer.getErrorPages().end(); it++) {
+			if (_errorPages.find(it->first) == _errorPages.end())
+				_errorPages[it->first] = it->second;
+		}
+	}
+};

commit 56d2d4f6d05a7311c75b50ad9484eef5b6f3b93e
Author: Tristan Czarniak <tristanczk@yahoo.fr>
Date:   Mon Jun 5 19:13:43 2023 +0200

    parsing of config files except listen and locations

diff --git a/includes/Location.hpp b/includes/Location.hpp
index 685072b..c91a622 100644
--- a/includes/Location.hpp
+++ b/includes/Location.hpp
@@ -1,3 +1,5 @@
+#pragma once
+
 class Location {
 public:
 private:

commit 2773666bfa056a58d2e9e59ce9e44ee8c2a70801
Author: tczarnia <tristanczk@yahoo.fr>
Date:   Sun May 28 14:51:20 2023 +0200

    start of parsing

diff --git a/includes/Location.hpp b/includes/Location.hpp
new file mode 100644
index 0000000..685072b
--- /dev/null
+++ b/includes/Location.hpp
@@ -0,0 +1,4 @@
+class Location {
+public:
+private:
+};
\ No newline at end of file
