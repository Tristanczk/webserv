#block must necessary start with blockname { (blockname can be server or location)
#block must necessary end with a } on a separate line, else the file would not be valid
#a { or } inside a line is not considered as a block delimiter
#unlike in nginx config file, lines don't need to end with a ; however all information regarding a keyword need to be on the same line
#keyword are case sensitive and must be written in lowercase
#in case of multiple occurence of the same line, we take the last occurences, the only exception are error_page and index
#error page consider the first value specified for a given error code, index consider all values specified merging the lists and taking the first valid file

server {
	listen 0.0.0.0:8080
	# we manage only an ip address or localhost plus un port
	# ip + port, is host the same as the ip address ? by default using 0.0.0.0:8080
	# ip can be replaced by a hostname, for instance localhost:8080
	# there can be ip only, or port only or both
	# first host:port correspondance is used as the default server for this host:port, what is the use of server name ?
	# if two servers listen on the same port, one with a specific IP and the other with a generic IP (0.0.0.0),
	# the one with the specific IP will have priority for all requests coming on this IP
	# context (= where it can be located in the config file) : server

	server_name website.com
	# set the name of a virtual server, allows to differentiate two virtual servers with the same host + port
	# there can be multiple server_names for a single server block, with their names separated by spaces
	# context : server

	root	/var/www/html
	# sets the root directory for accessing files for requests
	# if the request is /index.html, the file to serve is /var/www/html/index.html
	# there can be only one root directory per server block
	# it can be redifined in the location blocks if necessary
	# context : server, location

	autoindex off
	# off by default, if on, produces a directory listing for request ending with a /, if no index are specified
	# context : http (block encapsulating server block, not necessary for the project ?), server, location

	client_body_buffer_size 8k
	# by default 8k or 16k depending on the platform. It sets the buffer size for reading the client request body
	# if it is larger, then the entire (or partial if send by chunk) request body is written into a temporary file
	# not sure it is necessary for the project, I think the subject rather references client_max_body_size
	# context : http, server, location

	client_max_body_size 1M
	# by default 1 Mb, limits the size of the file that can be uploaded on the server
	# if the file is too large, sends a 413 Request Entity Too Large error
	# context : http, server, location

	error_page 404 /404.html
	# specifies the error page to display for a given error code
	# error 404 is the most common but we can specify pages for other error codes as well
	# if the specified path is a relative path, it is relative to the root directory of the server block
	# multiple error code can be associated with the same page on one line but each code must be separated by a space
	# similarly, we can specify range of codes with the following syntax : start-end
	# context : http, server, location

	index index.html index.php
	# specifies the page to display in case of a directory url request, sending back the first valid file in order
	# if no files are valid, display a directory listing if autoindex is on, else return a "403 Forbidden" error
	# context : http, server, location

	# when a request comes in, the server will try to match the request with the location blocks with the following priority, as per nginx doc (http://nginx.org/en/docs/http/ngx_http_core_module.html#location)
	# To find location matching a given request, nginx first checks locations defined using the prefix strings (prefix locations). 
	# Among them, the location with the longest matching prefix is selected and remembered. 
	# Then regular expressions are checked, in the order of their appearance in the configuration file. 
	# The search of regular expressions terminates on the first match, and the corresponding configuration is used. 
	# If no match with a regular expression is found then the configuration of the prefix location remembered earlier is used.
	# Also, using the “=” modifier it is possible to define an exact match of URI and location. 
	# If an exact match is found, the search terminates. 
	# For example, if a “/” request happens frequently, defining “location = /” will speed up the processing of these requests, 
	# as search terminates right after the first comparison. Such a location cannot obviously contain nested locations.
	location / {
		root /var/www/lol
		error_page 404 /404_new.html
		return 301 http://www.website.com
		# try_files $uri $uri/ /index.html
		# specifies the behaviour to follow when answering a request and potential fallbacks
		# for instance, here the server first tries to serve the requested file ($uri)
		# then it checks if there is a directory with the same name ($uri/), if found, the server tries to server the default file within the directory
		# if neither the file nor the directory exists, the server rewrites the request to /index.html
		# note: it is not asked in the webserv subject

	}
	# such a location indicates a regex match, \. means to match a dot, $ means to match the end of the string
	location ~ \.php$ {
		# specify cgi

	}
}